// A very preliminary test that uses VI and Instruction reflection 
// to generate source for building a static linked version of the run time 
// instructions like InstructionType require the VIREO_INSTRUCTION_REFLECTION flag


define (HelloWorld dv(.VirtualInstrument (
    c(
        e(dv(.String "Hello, Brandon") variable1)
        e(dv(.Int32  505) variable2)
        e(dv(.Boolean  true) variable3)
        e(dv(.Boolean  false) variable4)
        e(dv(.Boolean  false) vb1)
        e(dv(.Boolean  false) vb2)
        e(dv(.Boolean  false) vb3)
        e(dv(.Int8  508) v8)
        e(dv(.Int64 564) v64)
    )
    clump (
        Add(variable2 variable2 variable2)
        Sub(v8 v8 v8)
        Mul(v64 v64 v64)
        Println(variable1)
    )
    clump (
        Sub(variable2 variable2 variable2)
        Println(variable1)
        Println(variable1)
    )
) ) )

define (Converter dv(.VirtualInstrument (
    c(
        e(.Type     dsType)
        e(.Int32    count)
        e(.Int32    index)
        e(.Int32    zero)
        e(.Type     eltType)
        e(.String   typeName)  
        e(.String   eltName)  
        e(.String   eltValue) 
        e(a(.VIClump *) clumps) // alias to the array of clumps
        e(.VIClump clump)
        e(.Instruction inst)
        e(.Type  instructionType)
        e(.Type  parameterListType)
        e(.String internalName)
        
        // For iterating through parameter types
        e(.Int32    count2)
        e(.Int32    index2)
        e(.Int32    clumpIndex)
        e(.Int32    clumpCount)
        e(.Int32    argPointerCategory)
        e(.Type     argType)
        
        e(.DataPointer argValuePointer)
        e(.String argSymbolName)

    )
    clump (
        ArrayElementType(HelloWorld.DataSpace dsType)
        
        // Print the dataspace type
    
        TypeSubElementCount(dsType count)
        Printf("//-------------------------\n")
        Printf("class DST_HelloWorld {  \n" )
        Perch(0)
            TypeGetSubElement(dsType index eltType)
            TypeGetName(eltType typeName) 
            TypeGetElementName(eltType eltName) 
            Printf("  VT%s _%s;\n" typeName eltName)
            Add(index 1 index)
        BranchIfLT(0 index count)
        Printf("};\n")
        
        // Print the dataspace initializer

        Init(index)
        Printf("//-------------------------\n")
        Printf("DST_HelloWorld  ds = {  \n" )
        Perch(1)
            TypeGetSubElement(dsType index eltType)
            DefaultValueToString(eltType eltValue)
            Printf("  %s,\n" eltValue)
            Add(index 1 index)
        BranchIfLT(1 index count)
        Printf("};")

        // Print clump initializer

        Copy(HelloWorld.Clumps clumps)
       // CreateArrayItr(HelloWorld.Clumps clumpItr)
        
        ArrayLength(clumps clumpCount)
        Printf("\n")
        Printf("//-------------------------\n")
        
            Perch(5)
            // For each clump
            ArrayIndexElt(clumps clumpIndex clump)
            Copy(clump.CodeStart inst)
            Printf("Instructions _clump%d_instructions = {\n" clumpIndex)     
                
                //For each instruction
                Perch(3)
                InstructionType(inst instructionType internalName)
                TypeGetName(instructionType typeName)
                TypeGetSubElement(instructionType 0 parameterListType)
                
                Printf("   _I1(%s, " internalName)
                
                // For each argument in an instruction
                // The instruction type is a pointer.
                // To get acces to the pointer's description get its sub element
                TypeSubElementCount(parameterListType count2)
                Init(index2)
                
                    // Loop through all arguments 
                    Branch(4)
                    Perch(2)
                        // TypeGetSubElement(parameterListType index2 argType)
                        //TypeGetName(argType typeName) 
                        InstructionArg(inst index2 argValuePointer)
                        TypeManagerPointerToSymbol(* argValuePointer argSymbolName)

                        Printf("%s" argSymbolName)
                        Printf(", ")
                        Add(index2 1 index2)
                        Perch(4)
                    BranchIfLT(2 index2 count2)
                    Printf(")\n")
            
                InstructionNext(inst inst)
                BranchIfNotNull(3 inst)
                Printf("};\n")            

            Add(clumpIndex 1 clumpIndex)
            BranchIfLT(5 clumpIndex clumpCount)        

    )
) ) )


enqueue (Converter)

/*

InstructionItr 
ClumpItr
VirtualInstrumentItr
IntItr
ArgumentItr

//Iterator<.Instrument>

Iterator itr

InstructionCreateItr

An iterator can be created for any standard array 
using the following ArrayCreateItr

Any thing stored in a standard array can be iterated over using 
ArrayCreateItr(array iterator)
ArrayCreateItrEx(array iterator start end)
// How to specific the walking path?
ArrayCreateItrND(array iterator start end)


That covers many of common structures. A few have special ones

InstructionCreateItr
TypeManagerCreateTypeItr
ParameterCreateItr
 
 
ItrNext()
ItrNext(.ArrayItr)
ItrNext(.InstructionItr)
ItrNext(.TypeItr)

When the Iterator is create a done flag can/could be added that
the Next operation OR's in a done state

Will bind to the correct type of iterator

With a base Iterator a predicate iterator can be added as a wrapper. 




 
//Clumps, Queue?

//


itr.Value
itr.Next
itr.HasNext

How to access 


*/
